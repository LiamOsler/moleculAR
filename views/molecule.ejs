<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title><%= title %></title>
    <link rel='stylesheet' href='/styles/style.css' />
    <script src='/js/three.js'></script>
    <!-- include jsartookit -->
    <script src="/jsartoolkit5/artoolkit.min.js"></script>
    <script src="/jsartoolkit5/artoolkit.api.js"></script>
    <!-- include threex.artoolkit -->
    <script src="/threex/threex-artoolkitsource.js"></script>
    <script src="/threex/threex-artoolkitcontext.js"></script>
    <script src="/threex/threex-arbasecontrols.js"></script>
    <script src="/threex/threex-armarkercontrols.js"></script>

    <!-- include datgui debugging purposes -->
    <script type="text/javascript" src="/datgui/dat.gui.min.js"></script>

    <!-- include Mol file to CJSON conversion extras -->
    <script src="/cjson/converter.js"></script>

    <style>
      #gui_container{
        position: absolute;
        bottom: 0;
        right: 0;
        z-index: 1000 !important;
      }
      #gui{
        transform:translate(0, -20px);
      }
    </style>
  </head>

<html>
  <div id="mydiv" data-test=<%= testJSON %>></div>
  <body style='margin : 0px; overflow: hidden; font-family: Monospace;'>
  <div id="gui_container"></div>

  <!-- 
    Example created by Lee Stemkoski: https://github.com/stemkoski
    Based on the AR.js library and examples created by Jerome Etienne: https://github.com/jeromeetienne/AR.js/
  -->
  <script>
  
  var scene, camera, renderer, clock, deltaTime, totalTime;
  
  var arToolkitSource, arToolkitContext;
  
  var markerRoot1, markerRoot2;

  var moleculeGroup = new THREE.Group();

  var autoRotate = {
    switch: false
  }

  var mesh1;
  
  initialize();
  animate();
  
  function initialize()
  {
    scene = new THREE.Scene();
  
    let ambientLight = new THREE.AmbientLight( 0xffffff, 1 );
    scene.add( ambientLight );
          
    camera = new THREE.Camera();
    scene.add(camera);
  
    renderer = new THREE.WebGLRenderer({
      antialias : true,
      alpha: true
    });
    renderer.setClearColor(new THREE.Color('lightgrey'), 0)
    renderer.setSize( 640, 480 );
    renderer.domElement.style.position = 'absolute'
    renderer.domElement.style.top = '0px'
    renderer.domElement.style.left = '0px'
    document.body.appendChild( renderer.domElement );
  
    clock = new THREE.Clock();
    deltaTime = 0;
    totalTime = 0;
    
    ////////////////////////////////////////////////////////////
    // setup arToolkitSource
    ////////////////////////////////////////////////////////////
  
    arToolkitSource = new THREEx.ArToolkitSource({
      sourceType : 'webcam',
    });
  
    function onResize()
    {
      arToolkitSource.onResize()	
      arToolkitSource.copySizeTo(renderer.domElement)	
      if ( arToolkitContext.arController !== null )
      {
        arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
      }	
    }
  
    arToolkitSource.init(function onReady(){
      onResize()
    });
    
    // handle resize event
    window.addEventListener('resize', function(){
      onResize()
    });
    
    ////////////////////////////////////////////////////////////
    // setup arToolkitContext
    ////////////////////////////////////////////////////////////	
  
    // create atToolkitContext
    arToolkitContext = new THREEx.ArToolkitContext({
      cameraParametersUrl: '/data/camera_para.dat',
      detectionMode: 'mono'
    });
    
    // copy projection matrix to camera when initialization complete
    arToolkitContext.init( function onCompleted(){
      camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
    });
  
    ////////////////////////////////////////////////////////////
    // setup markerRoots
    ////////////////////////////////////////////////////////////
  
    // build markerControls
    markerRoot1 = new THREE.Group();
    scene.add(markerRoot1);
    let markerControls1 = new THREEx.ArMarkerControls(arToolkitContext, markerRoot1, {
      type: 'pattern', patternUrl: "/data/kanji.patt",
    })
  
    let geometry1	= new THREE.CubeGeometry(1,1,1);
    let material1	= new THREE.MeshNormalMaterial({
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    }); 

    let molfile = (<%- JSON.stringify(molfile) %>);
    let molObject = molFileToJSON(molfile);
    for(let item of molObject.atoms){
      let material;
      let meshNormalMaterial = new THREE.MeshNormalMaterial({
        transparent: true,
        opacity: 0.1,
        side: THREE.DoubleSide
      });
      switch(item.type){
        case "C":
          material = new THREE.MeshStandardMaterial( { 
            color: 0xaaaaaa,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
          } );
          break;
        case "H":
          material = new THREE.MeshStandardMaterial( { 
            color: 0xffffff,
            transparent: true,
            opacity: 0.9,
            side: THREE.DoubleSide
          } );
          break;
        case "O":
          material = new THREE.MeshStandardMaterial( { 
            color: 0xff0000,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
          } );
          break;
        case "N":
          material = new THREE.MeshStandardMaterial( { 
            color: 0x0000ff,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
          } );
          break;
        case "S":
          material = new THREE.MeshStandardMaterial( { 
            color: 0xffff00,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
          } );
          break;
        case "P":
          material = new THREE.MeshStandardMaterial( { 
            color: 0xffa500,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
          } );
          break;
        
        default:
          material = new THREE.MeshStandardMaterial( { 
            color: 0x555555,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
          } );
      }
      let geometry;
      switch(item.type){
        case "C":
          geometry = new THREE.SphereGeometry( .2, 32, 16 );
          geometry2 = new THREE.SphereGeometry( .3, 32, 16 );
          break;
        case "H":
          geometry = new THREE.SphereGeometry( .05, 32, 16 );
          geometry2 = new THREE.SphereGeometry( .3, 32, 16 );
          break;
        case "O":
          geometry = new THREE.SphereGeometry( .1, 32, 16 );
          geometry2 = new THREE.SphereGeometry( .3, 32, 16 );
          break;
        case "N":
          geometry = new THREE.SphereGeometry( .1, 32, 16 );
          geometry2 = new THREE.SphereGeometry( .3, 32, 16 );
          break;
        case "S":
          geometry = new THREE.SphereGeometry( .1, 32, 16 );
          geometry2 = new THREE.SphereGeometry( .3, 32, 16 );
          break;
        case "P":
          geometry = new THREE.SphereGeometry( .2, 32, 16 );
          geometry2 = new THREE.SphereGeometry( .3, 32, 16 );
          break;
        default:
          geometry = new THREE.SphereGeometry( .1, 32, 16 );
          geometry2 = new THREE.SphereGeometry( .3, 32, 16 );
      }
      const sphere = new THREE.Mesh( geometry, material );
      const normalSphere = new THREE.Mesh( geometry2, meshNormalMaterial );

      sphere.position.x = item.position.y/2;
      sphere.position.y = item.position.x/2;
      sphere.position.z = item.position.z/2;
      
      normalSphere.position.x = item.position.y/2;
      normalSphere.position.y = item.position.x/2;
      normalSphere.position.z = item.position.z/2;
      
      moleculeGroup.add( sphere );
      moleculeGroup.add( normalSphere );
    }

    var gui = new dat.GUI({ autoPlace: false });
    gui.domElement.id = 'gui';
    gui_container.appendChild(gui.domElement);
    const moleculePosition = gui.addFolder('Position')
    moleculePosition.add(moleculeGroup.position, 'x', -1, 1)
    moleculePosition.add(moleculeGroup.position, 'y', -1, 1)
    moleculePosition.add(moleculeGroup.position, 'z', -1, 1)

    const moleculeRotation = gui.addFolder('Rotation')
    moleculeRotation.add(moleculeGroup.rotation, 'x', -Math.PI*2, Math.PI*2)
    moleculeRotation.add(moleculeGroup.rotation, 'y', -Math.PI*2, Math.PI*2)
    moleculeRotation.add(moleculeGroup.rotation, 'z', -Math.PI*2, Math.PI*2)
    
    const moleculeScale = gui.addFolder('Scale')
    const scaleX = moleculeScale.add(moleculeGroup.scale, 'x', .1, 2).name("Scaling Factor")
    scaleX.onChange(function(value){
      moleculeGroup.scale.y = value;
      moleculeGroup.scale.z = value;
    })

    gui.add(autoRotate, "switch").name("Auto Rotate");


    
    markerRoot1.add( moleculeGroup );

    moleculeGroup.position.y = -1;
  
    // markerRoot1.add( sphere );
  }
  
  
  function update()
  {
    // update artoolkit on every frame
    if ( arToolkitSource.ready !== false )
      arToolkitContext.update( arToolkitSource.domElement );
  }
  
  
  function render()
  {
    renderer.render( scene, camera );
  }
  
  
  function animate()
  {
    requestAnimationFrame(animate);
    deltaTime = clock.getDelta();
    totalTime += deltaTime;

    if(autoRotate.switch){
      moleculeGroup.rotation.y+=.5*deltaTime;
    }
    // moleculeGroup.rotation.y+=.5*deltaTime;

    update();
    render();
  }
  
  </script>
  </body>
</html>